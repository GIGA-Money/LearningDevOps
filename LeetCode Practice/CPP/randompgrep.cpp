/* Evict a random page
  page replacement algorithm.

 The page reference stream is the same for the three algorithms.
 The number of page faults is computed for every algorithm.
 Using a Normal distribution for generating the page reference stream

 This model first generates a random sequence of page references,
 then it uses the three page replacement techniques on the same
 page sequence

 (C) J. Garrido - Nov. 2015, Rev. Feb. 2018
 File: randompgrep.cpp
*/

#include "proc.h"

using namespace std;

ofstream tracef; // output data file with trace
ofstream statf;  // file for summary results

// Globals
// Every page in the list has two components
struct rpage
{
    int page;    // page being referenced
    int p_occur; // next occurrence in page ref stream
};

double simperiod;

const int M_FRAME = 10;    // total size of frame allocation
const int PROG_SIZE = 35;  // program size, in pages
const int NUM_PAGES = 300; // total pages in page ref stream

long prstream[NUM_PAGES]; // page reference stream

// class for generation of random sequence of page references
class gen_pgrefs;
// class with fifo algorithm
class fifo;

simulation *run;
gen_pgrefs *pgens; // object that generates random pafe refs
fifo *pgfiforep;   // Random
                   //
                   // vector <rpage> list_page(M_FRAME); // list of pages in memory
typedef rpage *vector_ptr;
vector_ptr list_page;

//
int m_loc, m_i;
//
// Class Specifications
//
// The page reference stream is generated by an object of class gen_pgrefs
// using normal probability distribution
// An instance of this class is a passive object, instantiated from 'main'
//
class gen_pgrefs
{
    // Normal random number generator
    long mean_pag; // mean page
    long std;      // standard deviation for pages
    float cv;      // coefficient of variance
    normal *nselect_pg;

public:
    gen_pgrefs(string rname, long meanpg, float cvar);
    void generate();
};
//
//
// Random Algorithm for page replacement
class fifo : public process
{
    int mpage;      // number of pages in memory
    int j;          // index of current referenced page in page ref stream
    int num_faults; // number of page faults
    int ref_page;   // page being referenced
public:
    fifo(string sname);
    void Main_body();
    int get_faults(); // get total page faults
    int get_pages();  // get total pages referenced
};

class pgreplace : public process
{
public:
    pgreplace(string s);
    void Main_body();
};

//
// Implementations
// Generate page reference stream
//
gen_pgrefs::gen_pgrefs(string rname, long meanpg, float cvar)
{
    if (meanpg > PROG_SIZE)
    {
        cout << "Error: mean page greater than prog size" << endl;
        meanpg = PROG_SIZE / 2;
    }
    // Normal distribution with coef. of variance, cv
    cv = cvar;
    mean_pag = meanpg;
    std = long(float(mean_pag) * cv);
    // cout << rname << " Normal - var: " << cv << " " << mean_pag << " " << std << endl;
    nselect_pg = new normal(mean_pag, std);
}
//
void gen_pgrefs::generate()
{
    long page;
    // cout << "Generating page references" << endl;
    tracef << "Generating page references" << endl;
    for (int jj = 0; jj < NUM_PAGES; jj++)
    {
        page = (int)nselect_pg->draw();
        // discard pages out of range of the program
        while (page <= 0 || page > PROG_SIZE)
            page = (int)nselect_pg->draw();
        prstream[jj] = page;
        // cout << prstream[jj] << " ";
        tracef << prstream[jj] << " ";
    }
    // cout << "\n End of generation pg refs" << endl;
    tracef << "\n End of generation pg refs" << endl;
}
//
// Page Replacement Algorithms
// ---------------------------------------------------------------
//
// Random Page Replacement Algorithm
// Replace the page that has been in memory the longest
// Insert new page at the top, remove page at the bottom

fifo::fifo(string s) : process(s)
{
    mpage = 0;
    j = 0;
    num_faults = 0;
    // cout << s << " created" << endl;
}
//
void randompg::Main_body()
{
    int num_ref_page = 0;
    double simclock = Time();
    int ref_page = 0;
    int mem[mpage];
    int lru[mpage];
    int m;
    int pagefault = 0;
    int total_page_refs = 0;

    for (int k = 0; k < mpage; k++)
    {
        mem[k] = -1;
    }

    for (int k = 0; k < mpage; k++)
    {
        lru[k] = 0;
    }

    while (simclock < end_time)
    {
        simclock = Time();
        ref_page = (int)(300.0 * (simclock / end_time));
        if (ref_page > 299)
        {
            ref_page = 299;
        }
        total_page_refs++;
        m = ref_page % mpage;
        if (mem[m] != ref_page)
        {
            pagefault++;
            // Evict a random page
            int random_index = rand() % mpage;
            mem[random_index] = ref_page;
        }
    }

    /*
    int random_index = rand() % mpage;
    mem[random_index] = ref_page;
    ents First In First Out (Random)
    */

    report_stat("Total number of page references: ", total_page_refs);
    report_stat("Total page faults: ", pagefault);
    report_stat("Proportion of pg faults to pg refs.: ", ((double)pagefault) / total_page_refs);
}

int fifo::get_faults()
{
    return num_faults;
}

int fifo::get_pages()
{
    return j;
}

//
//
// -------------------------------------------------------------
//
pgreplace::pgreplace(string s) : process(s)
{
    // cout << s << " created" << endl;
}
//
void pgreplace::Main_body()
{
    int num_faults;
    int num_pages;

    //
    pgfiforep = new fifo("Random");

    // cout << "starting fifo" << endl;

    pgfiforep->pstart();

    // cout << " after starting fifo" << endl;
    //
    run->start_sim(simperiod); // start simulation

    num_faults = pgfiforep->get_faults();
    num_pages = pgfiforep->get_pages();
    cout << endl;
    cout << "Random - Total page faults: " << num_faults << endl;
    cout << "Total number of page references: " << num_pages << endl;
    cout << "Proportion of pg faults to pg refs.: "
         << float(num_faults) / float(num_pages) << endl;
    cout << endl;
    statf << endl;
    statf << "Random - Total page faults: " << num_faults << endl;
    statf << "Total number of page references: " << num_pages << endl;
    statf << "Proportion of pg faults to pg refs.: "
          << float(num_faults) / float(num_pages) << endl;
    statf << endl;
}
//
int main()
{
    pgreplace *prep_model;

    simperiod = 3500.0;
    list_page = new rpage[M_FRAME]; // create array
    long mean_pg = 20;              // mean page
    float cvar = 0.55f;             // coefficient of variance
    //
    run = new simulation("Random Page Replacement");

    run->set_statfile("randompgrep_stat.txt", statf);
    run->set_tracefile("randompgrep_trace.txt", tracef);

    statf << "Simulation of Random Page Replacement" << endl;
    statf << "-----------------------------------------------------------" << endl;
    cout << "Simulation of Random Page Replacement" << endl;
    cout << "-----------------------------------------------------------" << endl;
    //
    pgens = new gen_pgrefs("Generate page stream", mean_pg, cvar);
    //
    // control thread
    prep_model = new pgreplace("Control thread Pg Rep");
    prep_model->pstart();
    //
    run->end_sim(); // end simulation
    return 0;
}